/* eslint-disable no-use-before-define */
// @flow

import type { ComponentType, Node } from 'react';
import type { Action, BoundActions } from 'react-sweet-state';
import type { BrowserHistory, LocationShape } from 'history/createBrowserHistory';

// ./common/types
export type Location = {|
    pathname: string,
    search: string,
    hash: string,
|};

type Query = { [string]: string };

export type Match = {|
    /** TODO we are supporting `undefined` here because we are currently using both
     * this version of the `Match` type, and react-routers version (which allows for `undefined`)
     * To fix this we should move `matchPath` to our own util so we can apply our own types, then
     * decide if we want to support undefined types.
     */
    params: { [string]: string | null | typeof undefined },
    query: Query,
    isExact: boolean,
    path: string,
    url: string,
|};

export type MatchedRoute = {|
    route: Route,
    match: Match,
|};

export type RouteContext = {|
    location: Location,
    query: Query,
    route: Route | null,
    match: Match,
    action: HistoryAction,
|};

type RouteResourceLoading = boolean;

type RouteResourceTimestamp = number | null;

type RouteResourceError = Object | Error | null;

type RouteResourceData = Object | null;

type RouteResourcePromise = Promise<any> | null;

type RouteResourceResponse = {|
    loading: RouteResourceLoading,
    error: RouteResourceError,
    data: RouteResourceData,
    promise: RouteResourcePromise,
    expiresAt: RouteResourceTimestamp,
|};

type RouteResourceGettersArgs = [RouterStoreContext, ResourceStoreContext];

export type RouteResource = {|
    type: string,
    getKey: (...args: RouteResourceGettersArgs) => string,
    maxAge: number,
    getData: (...args: RouteResourceGettersArgs) => RouteResourcePromise,
|};

type RouteResources = RouteResource[];

type ResourceStoreContext = Object;

type RouteResourceDataForType = {
    [key: string]: RouteResourceResponse,
};

export type ResourceStoreData = { [type: string]: RouteResourceDataForType } | {||};

export type RouterStoreContext = {|
    route: Route | null,
    match: Match,
    query: Query,
    location: Location,
|};

export type Route = {|
    path: string,
    exact?: boolean,
    /** The component to render on match, typed explicitly */
    component: ComponentType<RouteContext>,
    /** If present, must return true to include the route. */
    enabled?: () => boolean,
    /** Signals that this is a redirect route, we need to handle these in a special way. */
    isRedirect?: boolean,
    /** Used to prevent transitions between app groups */
    group?: string,
    /** Unique name for the route */
    name: string,
    /**
     * Triggered before leaving the route, can trigger full page reload if returns (or resolves) false.
     * Defaults to true.
     */
    canTransitionOut?: (
        currentRouteMatch: MatchedRoute,
        nextRouteMatch: MatchedRoute,
        props: any,
    ) => boolean | Promise<boolean>,
    /**
     * Triggered before entering the route, can trigger full page reload if returns (or resolves) false.
     * Defaults to true.
     */
    canTransitionIn?: (
        currentRouteMatch: MatchedRoute,
        nextRouteMatch: MatchedRoute,
        props: any,
    ) => boolean | Promise<boolean>,
    /**
     * Query string matching. Each query param must match for the route to match.
     *
     * A query param can take the following shapes:
     *  * query name only: 'foo' - matches if query name 'foo' is present
     *  * query name matching value: 'foo=bar' - matches if query name 'foo' equals
     *    'bar' exactly
     *  * query name matching regex: 'foo=(bar.+) - matches if query name 'foo' equals
     *    regex '^(bar.+)$'. Note you must escape backslashes and wrap regex in parentheses.
     *  * query name NOT matching value: 'foo!=bar' - matches if query name 'foo' does
     *    not equal bar OR if query name 'foo' does not exist at all
     */
    query?: string[],
    /**
     * The navigation associated with the current route.
     */
    navigation: Navigation | null,
    /**
     * These query params will be ignored by the nav transition apdex event.
     */
    apdexIgnoreParams?: string[],
    /**
     * The resources for the route
     */
    resources?: RouteResources,
|};

type HistoryAction = 'PUSH' | 'REPLACE' | 'POP' | '';

export type Routes = Route[];

export type NavigationType = 'container' | 'product';

export type NavigationRenderUpdater = (location: Location, match: Match, route: Route) => Node;

export type NavigationStatics = {|
    type: NavigationType,
    view: (...args: any[]) => string,
|};

export type Navigation = {|
    ...NavigationStatics,
    renderNavigationUpdater: NavigationRenderUpdater,
|};

export type HistoryBlocker = (location: Location, action: string) => boolean | Promise<boolean>;

// ./controllers/router-store/types

type TransitionBlocker = (
    currentMatchedRoute: MatchedRoute | null,
    nextMatchedRoute: MatchedRoute | null,
    action: HistoryAction,
) => Promise<boolean>;

type PublicStateProperties = {|
    location: Location,
    query: Query,
    route: Route | null,
    match: Match,
    action: HistoryAction,
|};

type PrivateStateProperties = {|
    routes: Routes,
    history: BrowserHistory,
    unlisten: (() => void) | null,
    isStatic: boolean,
    transitionBlocker: TransitionBlocker,
    shouldUseSuspense: boolean,
|};

type EntireRouterState = {|
    ...PublicStateProperties,
    ...PrivateStateProperties,
|};

type ContainerProps = {|
    isStatic?: boolean,
    history: BrowserHistory,
    location?: Location,
    routes: Routes,
    transitionBlocker?: TransitionBlocker,
    resourceData?: ResourceStoreData,
    resourceContext?: ResourceStoreContext,
|};

// eslint-disable-next-line no-use-before-define
type RouterAction = Action<EntireRouterState, ContainerProps, AllRouterActions>;

type PrivateRouterActions = {|
    bootstrapStore: (initialState: ContainerProps) => RouterAction,
    requestRouteResources: () => RouterAction,
    listen: () => RouterAction,
|};

export type RouterActionsType = {|
    push: (path: string | LocationShape, state?: any) => RouterAction,
    replace: (path: string | LocationShape, state?: any) => RouterAction,
    goBack: () => RouterAction,
    goForward: () => RouterAction,
    registerBlock: (blocker: HistoryBlocker | any) => RouterAction,
|};

export type AllRouterActions = {|
    ...PrivateRouterActions,
    ...RouterActionsType,
|};

type RouterState = PublicStateProperties
export type RouterActionPush = (path: string | LocationShape, state?: any) => RouterAction;
export type RouterActionReplace = (path: string | LocationShape, state?: any) => RouterAction;
export type RouterSubscriberProps = {|
    children: (state: RouterState, actions: BoundActions<RouterActionsType>) => Node,
|};

export type LinkProps = {
  children: Node;
  target?: '_blank' | '_self' | '_parent' | '_top';
  href?: string;
  to?: string;
  replace?: boolean;
  type?: 'a' | 'button';
  onClick?: (e: any) => void;
};

export {
  Router,
  MemoryRouter,
  StaticRouter,
  RouterSubscriber,
  RouteResourceEnabledSubscriber,
  Redirect,
  RouterActions,
  withRouter,
  ResourceSubscriber,
  useResource,
  useRouter,
  useResourceStoreContext,
  createResource,
  useRouterActions,
  // $FlowFixMe
} from './controllers';
// $FlowFixMe
export { RouteComponent, Link, noopRouterDecorator } from './ui';
export {
  matchRoute,
  generatePath,
  createLegacyHistory,
  getRouteContext,
  // $FlowFixMe
} from './common/utils';
export {
  mockRouteContextProp,
  mockRouterStoreContextProp,
  // $FlowFixMe
} from './common/mocks';
